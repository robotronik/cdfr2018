ARM GAS  /tmp/ccoJRFYJ.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 2
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"robotronik_protocol.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.RP_FSM_INIT,"ax",%progbits
  21              		.align	2
  22              		.thumb
  23              		.thumb_func
  25              	RP_FSM_INIT:
  26              	.LFB8:
  27              		.file 1 "Src/robotronik_protocol.c"
   1:Src/robotronik_protocol.c **** /**
   2:Src/robotronik_protocol.c ****  * Library Robotronik Protocol
   3:Src/robotronik_protocol.c ****  * robotronik_protocol.c
   4:Src/robotronik_protocol.c ****  *
   5:Src/robotronik_protocol.c ****  * This library is meant to implement a light and reliable protocol
   6:Src/robotronik_protocol.c ****  * for communication between two MCUs. The protocol was designed for
   7:Src/robotronik_protocol.c ****  * request-response oriented communications. It is why it focuses on
   8:Src/robotronik_protocol.c ****  * performance for asynchronous reception.
   9:Src/robotronik_protocol.c ****  * 
  10:Src/robotronik_protocol.c ****  * It uses the Consistent Overhead Byte Stuffing algorithm to delimit
  11:Src/robotronik_protocol.c ****  * the frames and for synchronization purposes. CRC-16/BUYPASS is
  12:Src/robotronik_protocol.c ****  * used to detect corrupted frames.
  13:Src/robotronik_protocol.c ****  *
  14:Src/robotronik_protocol.c ****  * Copyright 2018 Antonin Hirschy
  15:Src/robotronik_protocol.c ****  *
  16:Src/robotronik_protocol.c ****  * This program is free software: you can redistribute it and/or modify
  17:Src/robotronik_protocol.c ****  * it under the terms of the GNU General Public License as published by
  18:Src/robotronik_protocol.c ****  * the Free Software Foundation, either version 3 of the License, or
  19:Src/robotronik_protocol.c ****  * (at your option) any later version.
  20:Src/robotronik_protocol.c ****  * 
  21:Src/robotronik_protocol.c ****  * This program is distributed in the hope that it will be useful,
  22:Src/robotronik_protocol.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23:Src/robotronik_protocol.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  24:Src/robotronik_protocol.c ****  * GNU General Public License for more details.
  25:Src/robotronik_protocol.c ****  *
  26:Src/robotronik_protocol.c ****  * You should have received a copy of the GNU General Public License
  27:Src/robotronik_protocol.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  28:Src/robotronik_protocol.c ****  */
  29:Src/robotronik_protocol.c **** #include "robotronik_protocol.h"
  30:Src/robotronik_protocol.c **** 
  31:Src/robotronik_protocol.c **** #define RP_EOF 0x00
ARM GAS  /tmp/ccoJRFYJ.s 			page 2


  32:Src/robotronik_protocol.c **** #define WRITE_BUFF(p_buffer,byte) *(p_buffer++) = byte;
  33:Src/robotronik_protocol.c **** #define ENCODE_BYTE(byte,p_buffer,p_code) {\
  34:Src/robotronik_protocol.c ****     if(byte == RP_EOF){			   \
  35:Src/robotronik_protocol.c ****       *p_code = p_buffer - p_code;	   \
  36:Src/robotronik_protocol.c ****       p_code = p_buffer++;		   \
  37:Src/robotronik_protocol.c ****     }					   \
  38:Src/robotronik_protocol.c ****     else{				   \
  39:Src/robotronik_protocol.c ****       *(p_buffer++) = byte;		   \
  40:Src/robotronik_protocol.c ****     }					   \
  41:Src/robotronik_protocol.c ****   }
  42:Src/robotronik_protocol.c **** 
  43:Src/robotronik_protocol.c **** static uint16_t err;
  44:Src/robotronik_protocol.c **** 
  45:Src/robotronik_protocol.c **** static void RP_FSM_INIT(RP_Interface *interface);
  46:Src/robotronik_protocol.c **** static void RP_FSM_ID(RP_Interface *interface);
  47:Src/robotronik_protocol.c **** static void RP_FSM_SIZE(RP_Interface *interface);
  48:Src/robotronik_protocol.c **** static void RP_FSM_DATA(RP_Interface *interface);
  49:Src/robotronik_protocol.c **** static void RP_FSM_CRC_LOW(RP_Interface *interface);
  50:Src/robotronik_protocol.c **** static void RP_FSM_CRC_HIGH(RP_Interface *interface);
  51:Src/robotronik_protocol.c **** static void RP_FSM_END(RP_Interface *interface);
  52:Src/robotronik_protocol.c **** 
  53:Src/robotronik_protocol.c **** //==================================================
  54:Src/robotronik_protocol.c **** //           Initialization functions
  55:Src/robotronik_protocol.c **** //==================================================
  56:Src/robotronik_protocol.c **** 
  57:Src/robotronik_protocol.c **** void RP_Init_Interface(RP_Interface *interface,
  58:Src/robotronik_protocol.c **** 		       uint8_t (*send)(uint8_t *, uint16_t, uint32_t),
  59:Src/robotronik_protocol.c **** 		       uint32_t (*get_tick)()){
  60:Src/robotronik_protocol.c ****   interface->send = send;
  61:Src/robotronik_protocol.c ****   interface->get_tick = get_tick;
  62:Src/robotronik_protocol.c ****   interface->received = false;
  63:Src/robotronik_protocol.c ****   
  64:Src/robotronik_protocol.c ****   //FSM
  65:Src/robotronik_protocol.c ****   interface->update_state = RP_FSM_INIT;
  66:Src/robotronik_protocol.c ****   interface->p_in = interface->buffer_in;
  67:Src/robotronik_protocol.c ****   interface->p_out = interface->r_packet.data;
  68:Src/robotronik_protocol.c ****   interface->crc_accum = 0;
  69:Src/robotronik_protocol.c **** }
  70:Src/robotronik_protocol.c **** 
  71:Src/robotronik_protocol.c **** void __attribute__((weak)) RP_Packet_Received(RP_Interface* interface, RP_Packet* packet){
  72:Src/robotronik_protocol.c ****   //Avoid compiler warnings.
  73:Src/robotronik_protocol.c ****   (void)interface;
  74:Src/robotronik_protocol.c ****   (void)packet;
  75:Src/robotronik_protocol.c **** }
  76:Src/robotronik_protocol.c **** 
  77:Src/robotronik_protocol.c **** void __attribute__((weak)) RP_Error_Handler(RP_Interface* interface, uint16_t err){
  78:Src/robotronik_protocol.c ****   //Avoid compiler warnings.
  79:Src/robotronik_protocol.c ****   (void)interface;
  80:Src/robotronik_protocol.c ****   (void)err;
  81:Src/robotronik_protocol.c ****  }
  82:Src/robotronik_protocol.c **** 
  83:Src/robotronik_protocol.c **** //==================================================
  84:Src/robotronik_protocol.c **** //           Sending functions
  85:Src/robotronik_protocol.c **** //==================================================
  86:Src/robotronik_protocol.c **** 
  87:Src/robotronik_protocol.c **** int RP_Build_Frame(RP_Packet *packet, uint8_t buffer[RP_BUFFER_SIZE]){
  88:Src/robotronik_protocol.c ****   if((packet->len <= 0) || (packet->len + 6 > RP_BUFFER_SIZE) || (packet->len > RP_MAX_PACKET_SIZE)
ARM GAS  /tmp/ccoJRFYJ.s 			page 3


  89:Src/robotronik_protocol.c ****     err =  RP_ERR_INTERNAL | RP_ERR_ILLEGAL_ARGUMENTS;
  90:Src/robotronik_protocol.c ****     return -1;
  91:Src/robotronik_protocol.c ****   }
  92:Src/robotronik_protocol.c **** 
  93:Src/robotronik_protocol.c ****   uint8_t *p_buffer = buffer;
  94:Src/robotronik_protocol.c ****   uint8_t *p_code = p_buffer++;
  95:Src/robotronik_protocol.c ****   uint16_t crc_accum = CRC_INIT;
  96:Src/robotronik_protocol.c **** 
  97:Src/robotronik_protocol.c ****   //ID
  98:Src/robotronik_protocol.c ****   const uint8_t id = packet->id;
  99:Src/robotronik_protocol.c ****   UPDATE_CRC(crc_accum, id);
 100:Src/robotronik_protocol.c ****   ENCODE_BYTE(id, p_buffer, p_code);
 101:Src/robotronik_protocol.c ****     
 102:Src/robotronik_protocol.c ****   //Size (remaining bytes)
 103:Src/robotronik_protocol.c ****   const uint8_t size = 4 + packet->len;
 104:Src/robotronik_protocol.c ****   UPDATE_CRC(crc_accum, size);
 105:Src/robotronik_protocol.c ****   *(p_buffer++) = size;
 106:Src/robotronik_protocol.c ****   
 107:Src/robotronik_protocol.c ****   int i;
 108:Src/robotronik_protocol.c ****   for(i = 0; i < packet->len; i++){
 109:Src/robotronik_protocol.c ****     const uint8_t byte = packet->data[i];
 110:Src/robotronik_protocol.c ****     UPDATE_CRC(crc_accum, byte);
 111:Src/robotronik_protocol.c ****     ENCODE_BYTE(byte, p_buffer, p_code);
 112:Src/robotronik_protocol.c ****   }
 113:Src/robotronik_protocol.c ****   
 114:Src/robotronik_protocol.c ****   //CRC-16
 115:Src/robotronik_protocol.c ****   uint8_t crc_low = crc_accum & 0xFF;
 116:Src/robotronik_protocol.c ****   uint8_t crc_high = crc_accum >> 8;
 117:Src/robotronik_protocol.c ****   ENCODE_BYTE(crc_low, p_buffer, p_code);
 118:Src/robotronik_protocol.c ****   ENCODE_BYTE(crc_high, p_buffer, p_code);
 119:Src/robotronik_protocol.c ****   
 120:Src/robotronik_protocol.c ****   //RP_EOF
 121:Src/robotronik_protocol.c ****   *p_code = p_buffer - p_code;
 122:Src/robotronik_protocol.c ****   *(p_buffer++) = RP_EOF;
 123:Src/robotronik_protocol.c **** 
 124:Src/robotronik_protocol.c ****   return p_buffer - buffer;
 125:Src/robotronik_protocol.c **** }
 126:Src/robotronik_protocol.c **** 
 127:Src/robotronik_protocol.c **** int RP_Sync(RP_Interface *interface, uint32_t timeout){
 128:Src/robotronik_protocol.c ****   uint8_t byte = RP_EOF;
 129:Src/robotronik_protocol.c **** 
 130:Src/robotronik_protocol.c ****   if(interface->send(&byte, 1, timeout) != 0){
 131:Src/robotronik_protocol.c ****     err = RP_ERR_LINK | RP_ERR_TIMEOUT;
 132:Src/robotronik_protocol.c ****     return -1;
 133:Src/robotronik_protocol.c ****   }
 134:Src/robotronik_protocol.c ****   
 135:Src/robotronik_protocol.c ****   return 0;
 136:Src/robotronik_protocol.c **** }
 137:Src/robotronik_protocol.c **** 
 138:Src/robotronik_protocol.c **** int RP_Send(RP_Interface *interface, RP_Packet *packet, uint32_t timeout){
 139:Src/robotronik_protocol.c ****   int len = RP_Build_Frame(packet, interface->buffer_out);
 140:Src/robotronik_protocol.c **** 
 141:Src/robotronik_protocol.c ****   if(len == -1){
 142:Src/robotronik_protocol.c ****     return -1;
 143:Src/robotronik_protocol.c ****   }
 144:Src/robotronik_protocol.c **** 
 145:Src/robotronik_protocol.c ****   if(interface->send(interface->buffer_out, len, timeout) != 0){
ARM GAS  /tmp/ccoJRFYJ.s 			page 4


 146:Src/robotronik_protocol.c ****     err = RP_ERR_LINK | RP_ERR_TIMEOUT;
 147:Src/robotronik_protocol.c ****     return -1;
 148:Src/robotronik_protocol.c ****   }
 149:Src/robotronik_protocol.c ****   
 150:Src/robotronik_protocol.c ****   return 0;
 151:Src/robotronik_protocol.c **** }
 152:Src/robotronik_protocol.c **** 
 153:Src/robotronik_protocol.c **** //==================================================
 154:Src/robotronik_protocol.c **** //           Receiving functions
 155:Src/robotronik_protocol.c **** //==================================================
 156:Src/robotronik_protocol.c **** 
 157:Src/robotronik_protocol.c **** void RP_Process_Data(RP_Interface *interface, uint8_t *data, uint16_t len){
 158:Src/robotronik_protocol.c ****   interface->p_in = data;
 159:Src/robotronik_protocol.c **** 
 160:Src/robotronik_protocol.c ****   while(len--){
 161:Src/robotronik_protocol.c ****     interface->update_state(interface);
 162:Src/robotronik_protocol.c ****   }
 163:Src/robotronik_protocol.c **** }
 164:Src/robotronik_protocol.c **** 
 165:Src/robotronik_protocol.c **** int RP_Wait_Packet(RP_Interface *interface, uint32_t timeout_ms){
 166:Src/robotronik_protocol.c ****   int start = interface->get_tick();
 167:Src/robotronik_protocol.c ****   
 168:Src/robotronik_protocol.c ****   //interface->received = false;
 169:Src/robotronik_protocol.c ****   while(!interface->received && (interface->get_tick() - start < timeout_ms));
 170:Src/robotronik_protocol.c ****   
 171:Src/robotronik_protocol.c ****   if(!interface->received){
 172:Src/robotronik_protocol.c ****     return -1;
 173:Src/robotronik_protocol.c ****   }
 174:Src/robotronik_protocol.c ****   
 175:Src/robotronik_protocol.c ****   interface->received = false;
 176:Src/robotronik_protocol.c ****   
 177:Src/robotronik_protocol.c ****   return 0;
 178:Src/robotronik_protocol.c **** }
 179:Src/robotronik_protocol.c **** 
 180:Src/robotronik_protocol.c **** #define FSM_UPDATE(fsm,state_function) fsm->update_state = state_function
 181:Src/robotronik_protocol.c **** 
 182:Src/robotronik_protocol.c **** #define FSM_GET_BYTE(fsm) uint8_t byte = *(fsm->p_in++);
 183:Src/robotronik_protocol.c **** 
 184:Src/robotronik_protocol.c **** #define FSM_BYTE byte
 185:Src/robotronik_protocol.c **** 
 186:Src/robotronik_protocol.c **** #define FSM_RESET(fsm) {						\
 187:Src/robotronik_protocol.c ****     FSM_UPDATE(fsm, RP_FSM_INIT);					\
 188:Src/robotronik_protocol.c ****     fsm->crc_accum = 0;							\
 189:Src/robotronik_protocol.c ****     fsm->p_out = fsm->r_packet.data;					\
 190:Src/robotronik_protocol.c ****     return;								\
 191:Src/robotronik_protocol.c ****   }
 192:Src/robotronik_protocol.c **** 
 193:Src/robotronik_protocol.c **** #define FSM_ERR(fsm, err_code) {		\
 194:Src/robotronik_protocol.c ****   err = err_code;				\
 195:Src/robotronik_protocol.c ****   RP_Error_Handler(fsm, err);			\
 196:Src/robotronik_protocol.c ****   FSM_RESET(fsm);				\
 197:Src/robotronik_protocol.c ****   }
 198:Src/robotronik_protocol.c **** 
 199:Src/robotronik_protocol.c **** #define FSM_CHECK_ERR(fsm, err_code) {		\
 200:Src/robotronik_protocol.c ****     if(FSM_BYTE == RP_EOF){			\
 201:Src/robotronik_protocol.c ****       FSM_ERR(fsm, err_code);			\
 202:Src/robotronik_protocol.c ****     }						\
ARM GAS  /tmp/ccoJRFYJ.s 			page 5


 203:Src/robotronik_protocol.c ****   }
 204:Src/robotronik_protocol.c **** 
 205:Src/robotronik_protocol.c **** #define FSM_CHECK_EOF(fsm) {			\
 206:Src/robotronik_protocol.c ****     if(FSM_BYTE == RP_EOF) {FSM_RESET(fsm);}	\
 207:Src/robotronik_protocol.c ****   }
 208:Src/robotronik_protocol.c **** /**
 209:Src/robotronik_protocol.c ****  * Reinit the FSM when EOF is reached.
 210:Src/robotronik_protocol.c ****  * Set the 'valid' flag of FSM
 211:Src/robotronik_protocol.c ****  * and the error code.
 212:Src/robotronik_protocol.c ****  */
 213:Src/robotronik_protocol.c **** 
 214:Src/robotronik_protocol.c **** #define FSM_DECODE_BYTE(fsm, byte)			\
 215:Src/robotronik_protocol.c ****   (((--fsm->bs_count) == 0)?				\
 216:Src/robotronik_protocol.c ****    (fsm->bs_count = byte, (uint8_t) RP_EOF):		\
 217:Src/robotronik_protocol.c ****    (byte))
 218:Src/robotronik_protocol.c **** /**
 219:Src/robotronik_protocol.c ****  * Update the COBS counter and decode the current byte. This macro can
 220:Src/robotronik_protocol.c ****  * be used once and only once in an fsm state. If the macro is not
 221:Src/robotronik_protocol.c ****  * used and the FSM is not reset, bs_count MUST be updated manually.
 222:Src/robotronik_protocol.c ****  */
 223:Src/robotronik_protocol.c **** 
 224:Src/robotronik_protocol.c **** static void RP_FSM_INIT(RP_Interface *interface){
  28              		.loc 1 224 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
 225:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
  34              		.loc 1 225 0
  35 0000 D0F80834 		ldr	r3, [r0, #1032]
  36 0004 5A1C     		adds	r2, r3, #1
  37 0006 C0F80824 		str	r2, [r0, #1032]
  38 000a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  39              	.LVL1:
 226:Src/robotronik_protocol.c ****   /* 
 227:Src/robotronik_protocol.c ****    * If current byte is EOF, the fsm is reset but no error is set :
 228:Src/robotronik_protocol.c ****    * it's just a blank frame that can be used for synchronisation
 229:Src/robotronik_protocol.c ****    * purpose.
 230:Src/robotronik_protocol.c ****    */
 231:Src/robotronik_protocol.c ****   FSM_CHECK_EOF(interface);
  40              		.loc 1 231 0
  41 000c 2BB1     		cbz	r3, .L5
 232:Src/robotronik_protocol.c **** 
 233:Src/robotronik_protocol.c ****   /*
 234:Src/robotronik_protocol.c ****    * The first byte initializes the COBS algorithm.
 235:Src/robotronik_protocol.c ****    */
 236:Src/robotronik_protocol.c ****   interface->bs_count = FSM_BYTE;
 237:Src/robotronik_protocol.c **** 
 238:Src/robotronik_protocol.c ****   FSM_UPDATE(interface, RP_FSM_ID);
  42              		.loc 1 238 0
  43 000e 084A     		ldr	r2, .L6
 236:Src/robotronik_protocol.c **** 
  44              		.loc 1 236 0
  45 0010 80F80434 		strb	r3, [r0, #1028]
  46              		.loc 1 238 0
  47 0014 C0F80024 		str	r2, [r0, #1024]
ARM GAS  /tmp/ccoJRFYJ.s 			page 6


  48 0018 7047     		bx	lr
  49              	.L5:
 231:Src/robotronik_protocol.c **** 
  50              		.loc 1 231 0 discriminator 1
  51 001a 064A     		ldr	r2, .L6+4
  52 001c A0F81034 		strh	r3, [r0, #1040]	@ movhi
  53 0020 00F58573 		add	r3, r0, #266
  54              	.LVL2:
  55 0024 C0F80024 		str	r2, [r0, #1024]
  56 0028 C0F80C34 		str	r3, [r0, #1036]
  57 002c 7047     		bx	lr
  58              	.L7:
  59 002e 00BF     		.align	2
  60              	.L6:
  61 0030 00000000 		.word	RP_FSM_ID
  62 0034 00000000 		.word	RP_FSM_INIT
  63              		.cfi_endproc
  64              	.LFE8:
  66              		.section	.text.RP_Init_Interface,"ax",%progbits
  67              		.align	2
  68              		.global	RP_Init_Interface
  69              		.thumb
  70              		.thumb_func
  72              	RP_Init_Interface:
  73              	.LFB0:
  59:Src/robotronik_protocol.c ****   interface->send = send;
  74              		.loc 1 59 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  79              	.LVL3:
  80 0000 30B4     		push	{r4, r5}
  81              	.LCFI0:
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 4, -8
  84              		.cfi_offset 5, -4
  62:Src/robotronik_protocol.c ****   
  85              		.loc 1 62 0
  86 0002 0023     		movs	r3, #0
  65:Src/robotronik_protocol.c ****   interface->p_in = interface->buffer_in;
  87              		.loc 1 65 0
  88 0004 094D     		ldr	r5, .L10
  60:Src/robotronik_protocol.c ****   interface->get_tick = get_tick;
  89              		.loc 1 60 0
  90 0006 0160     		str	r1, [r0]
  66:Src/robotronik_protocol.c ****   interface->p_out = interface->r_packet.data;
  91              		.loc 1 66 0
  92 0008 00F10804 		add	r4, r0, #8
  67:Src/robotronik_protocol.c ****   interface->crc_accum = 0;
  93              		.loc 1 67 0
  94 000c 00F58571 		add	r1, r0, #266
  95              	.LVL4:
  65:Src/robotronik_protocol.c ****   interface->p_in = interface->buffer_in;
  96              		.loc 1 65 0
  97 0010 C0F80054 		str	r5, [r0, #1024]
  66:Src/robotronik_protocol.c ****   interface->p_out = interface->r_packet.data;
ARM GAS  /tmp/ccoJRFYJ.s 			page 7


  98              		.loc 1 66 0
  99 0014 C0F80844 		str	r4, [r0, #1032]
  61:Src/robotronik_protocol.c ****   interface->received = false;
 100              		.loc 1 61 0
 101 0018 4260     		str	r2, [r0, #4]
  67:Src/robotronik_protocol.c ****   interface->crc_accum = 0;
 102              		.loc 1 67 0
 103 001a C0F80C14 		str	r1, [r0, #1036]
  62:Src/robotronik_protocol.c ****   
 104              		.loc 1 62 0
 105 001e 80F81234 		strb	r3, [r0, #1042]
  68:Src/robotronik_protocol.c **** }
 106              		.loc 1 68 0
 107 0022 A0F81034 		strh	r3, [r0, #1040]	@ movhi
  69:Src/robotronik_protocol.c **** 
 108              		.loc 1 69 0
 109 0026 30BC     		pop	{r4, r5}
 110              	.LCFI1:
 111              		.cfi_restore 5
 112              		.cfi_restore 4
 113              		.cfi_def_cfa_offset 0
 114 0028 7047     		bx	lr
 115              	.L11:
 116 002a 00BF     		.align	2
 117              	.L10:
 118 002c 00000000 		.word	RP_FSM_INIT
 119              		.cfi_endproc
 120              	.LFE0:
 122              		.section	.text.RP_Packet_Received,"ax",%progbits
 123              		.align	2
 124              		.weak	RP_Packet_Received
 125              		.thumb
 126              		.thumb_func
 128              	RP_Packet_Received:
 129              	.LFB1:
  71:Src/robotronik_protocol.c ****   //Avoid compiler warnings.
 130              		.loc 1 71 0
 131              		.cfi_startproc
 132              		@ args = 0, pretend = 0, frame = 0
 133              		@ frame_needed = 0, uses_anonymous_args = 0
 134              		@ link register save eliminated.
 135              	.LVL5:
 136 0000 7047     		bx	lr
 137              		.cfi_endproc
 138              	.LFE1:
 140 0002 00BF     		.section	.text.RP_Error_Handler,"ax",%progbits
 141              		.align	2
 142              		.weak	RP_Error_Handler
 143              		.thumb
 144              		.thumb_func
 146              	RP_Error_Handler:
 147              	.LFB2:
  77:Src/robotronik_protocol.c ****   //Avoid compiler warnings.
 148              		.loc 1 77 0
 149              		.cfi_startproc
 150              		@ args = 0, pretend = 0, frame = 0
 151              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccoJRFYJ.s 			page 8


 152              		@ link register save eliminated.
 153              	.LVL6:
 154 0000 7047     		bx	lr
 155              		.cfi_endproc
 156              	.LFE2:
 158 0002 00BF     		.section	.text.RP_FSM_ID,"ax",%progbits
 159              		.align	2
 160              		.thumb
 161              		.thumb_func
 163              	RP_FSM_ID:
 164              	.LFB9:
 239:Src/robotronik_protocol.c **** }
 240:Src/robotronik_protocol.c **** 
 241:Src/robotronik_protocol.c **** static void RP_FSM_ID(RP_Interface *interface){
 165              		.loc 1 241 0
 166              		.cfi_startproc
 167              		@ args = 0, pretend = 0, frame = 0
 168              		@ frame_needed = 0, uses_anonymous_args = 0
 169              	.LVL7:
 170              		.loc 1 241 0
 171 0000 38B5     		push	{r3, r4, r5, lr}
 172              	.LCFI2:
 173              		.cfi_def_cfa_offset 16
 174              		.cfi_offset 3, -16
 175              		.cfi_offset 4, -12
 176              		.cfi_offset 5, -8
 177              		.cfi_offset 14, -4
 242:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 178              		.loc 1 242 0
 179 0002 D0F80824 		ldr	r2, [r0, #1032]
 180 0006 511C     		adds	r1, r2, #1
 181 0008 C0F80814 		str	r1, [r0, #1032]
 182 000c 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
 183              	.LVL8:
 241:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 184              		.loc 1 241 0
 185 000e 0346     		mov	r3, r0
 243:Src/robotronik_protocol.c **** 
 244:Src/robotronik_protocol.c ****   /*
 245:Src/robotronik_protocol.c ****    * From this byte, reaching an EOF flag before the END state is
 246:Src/robotronik_protocol.c ****    * unexpected and will trigger an error.
 247:Src/robotronik_protocol.c ****    */
 248:Src/robotronik_protocol.c ****   FSM_CHECK_ERR(interface, RP_ERR_LINK | RP_ERR_UNEXPECTED_EOF);
 186              		.loc 1 248 0
 187 0010 E4B1     		cbz	r4, .L20
 249:Src/robotronik_protocol.c **** 
 250:Src/robotronik_protocol.c ****   /*
 251:Src/robotronik_protocol.c ****    * Note that the CRC is computed AFTER the byte is decoded. Indeed,
 252:Src/robotronik_protocol.c ****    * the CRC concerns the useful data.
 253:Src/robotronik_protocol.c ****    */
 254:Src/robotronik_protocol.c ****   FSM_BYTE = FSM_DECODE_BYTE(interface, FSM_BYTE);
 188              		.loc 1 254 0
 189 0012 90F80424 		ldrb	r2, [r0, #1028]	@ zero_extendqisi2
 255:Src/robotronik_protocol.c ****   interface->r_packet.id = FSM_BYTE;
 256:Src/robotronik_protocol.c ****   UPDATE_CRC(interface->crc_accum, FSM_BYTE);
 190              		.loc 1 256 0
 191 0016 B0F81014 		ldrh	r1, [r0, #1040]
ARM GAS  /tmp/ccoJRFYJ.s 			page 9


 192 001a 154D     		ldr	r5, .L21
 254:Src/robotronik_protocol.c ****   interface->r_packet.id = FSM_BYTE;
 193              		.loc 1 254 0
 194 001c 013A     		subs	r2, r2, #1
 195 001e 12F0FF02 		ands	r2, r2, #255
 196 0022 06BF     		itte	eq
 197 0024 80F80444 		strbeq	r4, [r0, #1028]
 198 0028 1446     		moveq	r4, r2
 199              	.LVL9:
 200 002a 80F80424 		strbne	r2, [r0, #1028]
 201              		.loc 1 256 0
 202 002e 84EA1122 		eor	r2, r4, r1, lsr #8
 203 0032 D2B2     		uxtb	r2, r2
 255:Src/robotronik_protocol.c ****   interface->r_packet.id = FSM_BYTE;
 204              		.loc 1 255 0
 205 0034 80F80841 		strb	r4, [r0, #264]
 206              		.loc 1 256 0
 207 0038 35F81220 		ldrh	r2, [r5, r2, lsl #1]
 257:Src/robotronik_protocol.c **** 
 258:Src/robotronik_protocol.c ****   FSM_UPDATE(interface, RP_FSM_SIZE);
 208              		.loc 1 258 0
 209 003c 0D48     		ldr	r0, .L21+4
 210              	.LVL10:
 211 003e C3F80004 		str	r0, [r3, #1024]
 256:Src/robotronik_protocol.c **** 
 212              		.loc 1 256 0
 213 0042 82EA0122 		eor	r2, r2, r1, lsl #8
 214 0046 A3F81024 		strh	r2, [r3, #1040]	@ movhi
 215 004a 38BD     		pop	{r3, r4, r5, pc}
 216              	.LVL11:
 217              	.L20:
 218              	.LBB4:
 219              	.LBB5:
 248:Src/robotronik_protocol.c **** 
 220              		.loc 1 248 0
 221 004c 40F20123 		movw	r3, #513
 222 0050 094A     		ldr	r2, .L21+8
 223 0052 0546     		mov	r5, r0
 224              	.LVL12:
 225 0054 1946     		mov	r1, r3
 226 0056 1380     		strh	r3, [r2]	@ movhi
 227 0058 FFF7FEFF 		bl	RP_Error_Handler
 228              	.LVL13:
 229 005c 074A     		ldr	r2, .L21+12
 230 005e A5F81044 		strh	r4, [r5, #1040]	@ movhi
 231 0062 05F58573 		add	r3, r5, #266
 232 0066 C5F80024 		str	r2, [r5, #1024]
 233 006a C5F80C34 		str	r3, [r5, #1036]
 234 006e 38BD     		pop	{r3, r4, r5, pc}
 235              	.LVL14:
 236              	.L22:
 237              		.align	2
 238              	.L21:
 239 0070 00000000 		.word	crc_table
 240 0074 00000000 		.word	RP_FSM_SIZE
 241 0078 00000000 		.word	.LANCHOR0
 242 007c 00000000 		.word	RP_FSM_INIT
ARM GAS  /tmp/ccoJRFYJ.s 			page 10


 243              	.LBE5:
 244              	.LBE4:
 245              		.cfi_endproc
 246              	.LFE9:
 248              		.section	.text.RP_FSM_SIZE,"ax",%progbits
 249              		.align	2
 250              		.thumb
 251              		.thumb_func
 253              	RP_FSM_SIZE:
 254              	.LFB10:
 259:Src/robotronik_protocol.c **** }
 260:Src/robotronik_protocol.c **** 
 261:Src/robotronik_protocol.c **** static void RP_FSM_SIZE(RP_Interface *interface){
 255              		.loc 1 261 0
 256              		.cfi_startproc
 257              		@ args = 0, pretend = 0, frame = 0
 258              		@ frame_needed = 0, uses_anonymous_args = 0
 259              	.LVL15:
 260 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 261              	.LCFI3:
 262              		.cfi_def_cfa_offset 24
 263              		.cfi_offset 3, -24
 264              		.cfi_offset 4, -20
 265              		.cfi_offset 5, -16
 266              		.cfi_offset 6, -12
 267              		.cfi_offset 7, -8
 268              		.cfi_offset 14, -4
 262:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 269              		.loc 1 262 0
 270 0002 D0F80834 		ldr	r3, [r0, #1032]
 271 0006 5A1C     		adds	r2, r3, #1
 272 0008 C0F80824 		str	r2, [r0, #1032]
 273 000c 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 274              	.LVL16:
 261:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 275              		.loc 1 261 0
 276 000e 0446     		mov	r4, r0
 263:Src/robotronik_protocol.c **** 
 264:Src/robotronik_protocol.c ****   FSM_CHECK_ERR(interface, RP_ERR_LINK | RP_ERR_UNEXPECTED_EOF);
 277              		.loc 1 264 0
 278 0010 EDB1     		cbz	r5, .L28
 265:Src/robotronik_protocol.c **** 
 266:Src/robotronik_protocol.c ****   /*
 267:Src/robotronik_protocol.c ****    * FSM_DECODE_BYTE is not used here because the protocol requires
 268:Src/robotronik_protocol.c ****    * that the size is > 0. So bs_count is decremented manually.
 269:Src/robotronik_protocol.c ****    */
 270:Src/robotronik_protocol.c ****   --(interface->bs_count);
 271:Src/robotronik_protocol.c **** 
 272:Src/robotronik_protocol.c ****   /*
 273:Src/robotronik_protocol.c ****    * For the states RP_FSM_SIZE and RP_FSM_DATA, the CRC must be
 274:Src/robotronik_protocol.c ****    * updated for each byte.
 275:Src/robotronik_protocol.c ****    */
 276:Src/robotronik_protocol.c ****   UPDATE_CRC(interface->crc_accum, FSM_BYTE);
 279              		.loc 1 276 0
 280 0012 B0F81064 		ldrh	r6, [r0, #1040]
 281 0016 1F49     		ldr	r1, .L30
 270:Src/robotronik_protocol.c **** 
ARM GAS  /tmp/ccoJRFYJ.s 			page 11


 282              		.loc 1 270 0
 283 0018 90F80424 		ldrb	r2, [r0, #1028]	@ zero_extendqisi2
 284              		.loc 1 276 0
 285 001c 85EA1627 		eor	r7, r5, r6, lsr #8
 277:Src/robotronik_protocol.c ****   /*
 278:Src/robotronik_protocol.c ****    * Get the packet length. It will be used to find the CRC position.
 279:Src/robotronik_protocol.c ****    */
 280:Src/robotronik_protocol.c ****   interface->size = interface->remaining = FSM_BYTE - 4;
 286              		.loc 1 280 0
 287 0020 2B1F     		subs	r3, r5, #4
 276:Src/robotronik_protocol.c ****   /*
 288              		.loc 1 276 0
 289 0022 31F81710 		ldrh	r1, [r1, r7, lsl #1]
 290              		.loc 1 280 0
 291 0026 DBB2     		uxtb	r3, r3
 276:Src/robotronik_protocol.c ****   /*
 292              		.loc 1 276 0
 293 0028 81EA0621 		eor	r1, r1, r6, lsl #8
 270:Src/robotronik_protocol.c **** 
 294              		.loc 1 270 0
 295 002c 013A     		subs	r2, r2, #1
 281:Src/robotronik_protocol.c ****   interface->r_packet.len = interface->size;
 282:Src/robotronik_protocol.c ****   
 283:Src/robotronik_protocol.c ****   /*
 284:Src/robotronik_protocol.c ****    * Checks wether or not the read size is consistent.
 285:Src/robotronik_protocol.c ****    */
 286:Src/robotronik_protocol.c ****   if(interface->size > RP_MAX_PACKET_SIZE){
 296              		.loc 1 286 0
 297 002e FA2B     		cmp	r3, #250
 280:Src/robotronik_protocol.c ****   interface->r_packet.len = interface->size;
 298              		.loc 1 280 0
 299 0030 80F80634 		strb	r3, [r0, #1030]
 300 0034 80F80534 		strb	r3, [r0, #1029]
 276:Src/robotronik_protocol.c ****   /*
 301              		.loc 1 276 0
 302 0038 A0F81014 		strh	r1, [r0, #1040]	@ movhi
 281:Src/robotronik_protocol.c ****   interface->r_packet.len = interface->size;
 303              		.loc 1 281 0
 304 003c 80F80931 		strb	r3, [r0, #265]
 270:Src/robotronik_protocol.c **** 
 305              		.loc 1 270 0
 306 0040 80F80424 		strb	r2, [r0, #1028]
 307              		.loc 1 286 0
 308 0044 14D8     		bhi	.L29
 287:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_SIZE);
 288:Src/robotronik_protocol.c ****   }
 289:Src/robotronik_protocol.c ****   
 290:Src/robotronik_protocol.c ****   FSM_UPDATE(interface, RP_FSM_DATA);
 309              		.loc 1 290 0
 310 0046 144B     		ldr	r3, .L30+4
 311 0048 C0F80034 		str	r3, [r0, #1024]
 312 004c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 313              	.LVL17:
 314              	.L28:
 264:Src/robotronik_protocol.c **** 
 315              		.loc 1 264 0 discriminator 1
 316 004e 40F20123 		movw	r3, #513
ARM GAS  /tmp/ccoJRFYJ.s 			page 12


 317 0052 124A     		ldr	r2, .L30+8
 318 0054 1946     		mov	r1, r3
 319 0056 1380     		strh	r3, [r2]	@ movhi
 320 0058 FFF7FEFF 		bl	RP_Error_Handler
 321              	.LVL18:
 322 005c 104A     		ldr	r2, .L30+12
 323 005e A4F81054 		strh	r5, [r4, #1040]	@ movhi
 324 0062 04F58573 		add	r3, r4, #266
 325 0066 C4F80024 		str	r2, [r4, #1024]
 326 006a C4F80C34 		str	r3, [r4, #1036]
 327 006e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 328              	.LVL19:
 329              	.L29:
 330              	.LBB8:
 331              	.LBB9:
 287:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_SIZE);
 332              		.loc 1 287 0
 333 0070 40F20223 		movw	r3, #514
 334 0074 094A     		ldr	r2, .L30+8
 335 0076 1946     		mov	r1, r3
 336 0078 1380     		strh	r3, [r2]	@ movhi
 337 007a FFF7FEFF 		bl	RP_Error_Handler
 338              	.LVL20:
 339 007e 084B     		ldr	r3, .L30+12
 340 0080 C4F80034 		str	r3, [r4, #1024]
 341 0084 0022     		movs	r2, #0
 342 0086 04F58573 		add	r3, r4, #266
 343 008a A4F81024 		strh	r2, [r4, #1040]	@ movhi
 344 008e C4F80C34 		str	r3, [r4, #1036]
 345 0092 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 346              	.LVL21:
 347              	.L31:
 348              		.align	2
 349              	.L30:
 350 0094 00000000 		.word	crc_table
 351 0098 00000000 		.word	RP_FSM_DATA
 352 009c 00000000 		.word	.LANCHOR0
 353 00a0 00000000 		.word	RP_FSM_INIT
 354              	.LBE9:
 355              	.LBE8:
 356              		.cfi_endproc
 357              	.LFE10:
 359              		.section	.text.RP_FSM_DATA,"ax",%progbits
 360              		.align	2
 361              		.thumb
 362              		.thumb_func
 364              	RP_FSM_DATA:
 365              	.LFB11:
 291:Src/robotronik_protocol.c **** }
 292:Src/robotronik_protocol.c **** 
 293:Src/robotronik_protocol.c **** static void RP_FSM_DATA(RP_Interface *interface){
 366              		.loc 1 293 0
 367              		.cfi_startproc
 368              		@ args = 0, pretend = 0, frame = 0
 369              		@ frame_needed = 0, uses_anonymous_args = 0
 370              	.LVL22:
 371 0000 38B5     		push	{r3, r4, r5, lr}
ARM GAS  /tmp/ccoJRFYJ.s 			page 13


 372              	.LCFI4:
 373              		.cfi_def_cfa_offset 16
 374              		.cfi_offset 3, -16
 375              		.cfi_offset 4, -12
 376              		.cfi_offset 5, -8
 377              		.cfi_offset 14, -4
 294:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 378              		.loc 1 294 0
 379 0002 D0F80824 		ldr	r2, [r0, #1032]
 380 0006 511C     		adds	r1, r2, #1
 381 0008 C0F80814 		str	r1, [r0, #1032]
 382 000c 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
 383              	.LVL23:
 293:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 384              		.loc 1 293 0
 385 000e 0346     		mov	r3, r0
 295:Src/robotronik_protocol.c ****   FSM_CHECK_ERR(interface, RP_ERR_LINK | RP_ERR_UNEXPECTED_EOF);
 386              		.loc 1 295 0
 387 0010 3CB3     		cbz	r4, .L38
 296:Src/robotronik_protocol.c **** 
 297:Src/robotronik_protocol.c ****   FSM_BYTE = FSM_DECODE_BYTE(interface, FSM_BYTE);
 388              		.loc 1 297 0
 389 0012 90F80424 		ldrb	r2, [r0, #1028]	@ zero_extendqisi2
 298:Src/robotronik_protocol.c ****   *(interface->p_out++) = FSM_BYTE;
 299:Src/robotronik_protocol.c ****   UPDATE_CRC(interface->crc_accum, FSM_BYTE);
 390              		.loc 1 299 0
 391 0016 1C4D     		ldr	r5, .L39
 297:Src/robotronik_protocol.c ****   *(interface->p_out++) = FSM_BYTE;
 392              		.loc 1 297 0
 393 0018 013A     		subs	r2, r2, #1
 394 001a 12F0FF02 		ands	r2, r2, #255
 395 001e 12BF     		itee	ne
 396 0020 80F80424 		strbne	r2, [r0, #1028]
 397 0024 80F80444 		strbeq	r4, [r0, #1028]
 398 0028 1446     		moveq	r4, r2
 399              	.LVL24:
 298:Src/robotronik_protocol.c ****   *(interface->p_out++) = FSM_BYTE;
 400              		.loc 1 298 0
 401 002a D0F80C24 		ldr	r2, [r0, #1036]
 402 002e 501C     		adds	r0, r2, #1
 403              	.LVL25:
 404 0030 C3F80C04 		str	r0, [r3, #1036]
 405 0034 1470     		strb	r4, [r2]
 406              		.loc 1 299 0
 407 0036 B3F81004 		ldrh	r0, [r3, #1040]
 300:Src/robotronik_protocol.c **** 
 301:Src/robotronik_protocol.c ****   if(!(--interface->remaining)){
 408              		.loc 1 301 0
 409 003a 93F80624 		ldrb	r2, [r3, #1030]	@ zero_extendqisi2
 299:Src/robotronik_protocol.c **** 
 410              		.loc 1 299 0
 411 003e 84EA1021 		eor	r1, r4, r0, lsr #8
 412 0042 C9B2     		uxtb	r1, r1
 413              		.loc 1 301 0
 414 0044 013A     		subs	r2, r2, #1
 299:Src/robotronik_protocol.c **** 
 415              		.loc 1 299 0
ARM GAS  /tmp/ccoJRFYJ.s 			page 14


 416 0046 35F81110 		ldrh	r1, [r5, r1, lsl #1]
 417              		.loc 1 301 0
 418 004a D2B2     		uxtb	r2, r2
 299:Src/robotronik_protocol.c **** 
 419              		.loc 1 299 0
 420 004c 81EA0021 		eor	r1, r1, r0, lsl #8
 421 0050 A3F81014 		strh	r1, [r3, #1040]	@ movhi
 422              		.loc 1 301 0
 423 0054 83F80624 		strb	r2, [r3, #1030]
 424 0058 12B9     		cbnz	r2, .L32
 302:Src/robotronik_protocol.c ****     /*
 303:Src/robotronik_protocol.c ****      * According to the size read, the next bytes should contains CRC
 304:Src/robotronik_protocol.c ****      * information.
 305:Src/robotronik_protocol.c ****      */
 306:Src/robotronik_protocol.c ****     FSM_UPDATE(interface, RP_FSM_CRC_LOW);
 425              		.loc 1 306 0
 426 005a 0C4A     		ldr	r2, .L39+4
 427 005c C3F80024 		str	r2, [r3, #1024]
 428              	.L32:
 429 0060 38BD     		pop	{r3, r4, r5, pc}
 430              	.LVL26:
 431              	.L38:
 432              	.LBB12:
 433              	.LBB13:
 295:Src/robotronik_protocol.c **** 
 434              		.loc 1 295 0
 435 0062 40F20123 		movw	r3, #513
 436 0066 0A4A     		ldr	r2, .L39+8
 437 0068 0546     		mov	r5, r0
 438              	.LVL27:
 439 006a 1946     		mov	r1, r3
 440 006c 1380     		strh	r3, [r2]	@ movhi
 441 006e FFF7FEFF 		bl	RP_Error_Handler
 442              	.LVL28:
 443 0072 084A     		ldr	r2, .L39+12
 444 0074 A5F81044 		strh	r4, [r5, #1040]	@ movhi
 445 0078 05F58573 		add	r3, r5, #266
 446 007c C5F80024 		str	r2, [r5, #1024]
 447 0080 C5F80C34 		str	r3, [r5, #1036]
 448 0084 38BD     		pop	{r3, r4, r5, pc}
 449              	.LVL29:
 450              	.L40:
 451 0086 00BF     		.align	2
 452              	.L39:
 453 0088 00000000 		.word	crc_table
 454 008c 00000000 		.word	RP_FSM_CRC_LOW
 455 0090 00000000 		.word	.LANCHOR0
 456 0094 00000000 		.word	RP_FSM_INIT
 457              	.LBE13:
 458              	.LBE12:
 459              		.cfi_endproc
 460              	.LFE11:
 462              		.section	.text.RP_FSM_CRC_LOW,"ax",%progbits
 463              		.align	2
 464              		.thumb
 465              		.thumb_func
 467              	RP_FSM_CRC_LOW:
ARM GAS  /tmp/ccoJRFYJ.s 			page 15


 468              	.LFB12:
 307:Src/robotronik_protocol.c ****   }
 308:Src/robotronik_protocol.c **** }
 309:Src/robotronik_protocol.c **** 
 310:Src/robotronik_protocol.c **** static void RP_FSM_CRC_LOW(RP_Interface *interface){
 469              		.loc 1 310 0
 470              		.cfi_startproc
 471              		@ args = 0, pretend = 0, frame = 0
 472              		@ frame_needed = 0, uses_anonymous_args = 0
 473              	.LVL30:
 474 0000 38B5     		push	{r3, r4, r5, lr}
 475              	.LCFI5:
 476              		.cfi_def_cfa_offset 16
 477              		.cfi_offset 3, -16
 478              		.cfi_offset 4, -12
 479              		.cfi_offset 5, -8
 480              		.cfi_offset 14, -4
 311:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 481              		.loc 1 311 0
 482 0002 D0F80834 		ldr	r3, [r0, #1032]
 483 0006 5A1C     		adds	r2, r3, #1
 484 0008 C0F80824 		str	r2, [r0, #1032]
 485 000c 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 486              	.LVL31:
 310:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 487              		.loc 1 310 0
 488 000e 0446     		mov	r4, r0
 312:Src/robotronik_protocol.c ****   FSM_CHECK_ERR(interface, RP_ERR_LINK | RP_ERR_UNEXPECTED_EOF);
 489              		.loc 1 312 0
 490 0010 25B3     		cbz	r5, .L48
 313:Src/robotronik_protocol.c **** 
 314:Src/robotronik_protocol.c ****   /*
 315:Src/robotronik_protocol.c ****    * Checks the low byte of CRC, and triggers an error if it doesn't match.
 316:Src/robotronik_protocol.c ****    */
 317:Src/robotronik_protocol.c ****   if((interface->crc_accum & 0xFF) != FSM_DECODE_BYTE(interface, FSM_BYTE)){
 491              		.loc 1 317 0
 492 0012 90F80424 		ldrb	r2, [r0, #1028]	@ zero_extendqisi2
 493 0016 90F81014 		ldrb	r1, [r0, #1040]	@ zero_extendqisi2
 494 001a 531E     		subs	r3, r2, #1
 495 001c 13F0FF03 		ands	r3, r3, #255
 496 0020 1ABF     		itte	ne
 497 0022 80F80434 		strbne	r3, [r0, #1028]
 498 0026 2B46     		movne	r3, r5
 499 0028 80F80454 		strbeq	r5, [r0, #1028]
 500 002c 9942     		cmp	r1, r3
 501 002e 03D1     		bne	.L49
 318:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_CRC);
 319:Src/robotronik_protocol.c ****   }else{
 320:Src/robotronik_protocol.c ****     FSM_UPDATE(interface, RP_FSM_CRC_HIGH);
 502              		.loc 1 320 0
 503 0030 134B     		ldr	r3, .L50
 504 0032 C0F80034 		str	r3, [r0, #1024]
 505 0036 38BD     		pop	{r3, r4, r5, pc}
 506              	.LVL32:
 507              	.L49:
 318:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_CRC);
 508              		.loc 1 318 0
ARM GAS  /tmp/ccoJRFYJ.s 			page 16


 509 0038 40F20323 		movw	r3, #515
 510 003c 114A     		ldr	r2, .L50+4
 511 003e 1946     		mov	r1, r3
 512 0040 1380     		strh	r3, [r2]	@ movhi
 513 0042 FFF7FEFF 		bl	RP_Error_Handler
 514              	.LVL33:
 515 0046 104B     		ldr	r3, .L50+8
 516 0048 C4F80034 		str	r3, [r4, #1024]
 517 004c 0022     		movs	r2, #0
 518 004e 04F58573 		add	r3, r4, #266
 519 0052 A4F81024 		strh	r2, [r4, #1040]	@ movhi
 520 0056 C4F80C34 		str	r3, [r4, #1036]
 521 005a 38BD     		pop	{r3, r4, r5, pc}
 522              	.LVL34:
 523              	.L48:
 524              	.LBB16:
 525              	.LBB17:
 312:Src/robotronik_protocol.c **** 
 526              		.loc 1 312 0
 527 005c 40F20123 		movw	r3, #513
 528 0060 084A     		ldr	r2, .L50+4
 529 0062 1946     		mov	r1, r3
 530 0064 1380     		strh	r3, [r2]	@ movhi
 531 0066 FFF7FEFF 		bl	RP_Error_Handler
 532              	.LVL35:
 533 006a 074A     		ldr	r2, .L50+8
 534 006c A4F81054 		strh	r5, [r4, #1040]	@ movhi
 535 0070 04F58573 		add	r3, r4, #266
 536 0074 C4F80024 		str	r2, [r4, #1024]
 537 0078 C4F80C34 		str	r3, [r4, #1036]
 538 007c 38BD     		pop	{r3, r4, r5, pc}
 539              	.LVL36:
 540              	.L51:
 541 007e 00BF     		.align	2
 542              	.L50:
 543 0080 00000000 		.word	RP_FSM_CRC_HIGH
 544 0084 00000000 		.word	.LANCHOR0
 545 0088 00000000 		.word	RP_FSM_INIT
 546              	.LBE17:
 547              	.LBE16:
 548              		.cfi_endproc
 549              	.LFE12:
 551              		.section	.text.RP_FSM_CRC_HIGH,"ax",%progbits
 552              		.align	2
 553              		.thumb
 554              		.thumb_func
 556              	RP_FSM_CRC_HIGH:
 557              	.LFB13:
 321:Src/robotronik_protocol.c ****   }
 322:Src/robotronik_protocol.c **** }
 323:Src/robotronik_protocol.c **** 
 324:Src/robotronik_protocol.c **** static void RP_FSM_CRC_HIGH(RP_Interface *interface){
 558              		.loc 1 324 0
 559              		.cfi_startproc
 560              		@ args = 0, pretend = 0, frame = 0
 561              		@ frame_needed = 0, uses_anonymous_args = 0
 562              	.LVL37:
ARM GAS  /tmp/ccoJRFYJ.s 			page 17


 563 0000 38B5     		push	{r3, r4, r5, lr}
 564              	.LCFI6:
 565              		.cfi_def_cfa_offset 16
 566              		.cfi_offset 3, -16
 567              		.cfi_offset 4, -12
 568              		.cfi_offset 5, -8
 569              		.cfi_offset 14, -4
 325:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 570              		.loc 1 325 0
 571 0002 D0F80834 		ldr	r3, [r0, #1032]
 572 0006 5A1C     		adds	r2, r3, #1
 573 0008 C0F80824 		str	r2, [r0, #1032]
 574 000c 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 575              	.LVL38:
 324:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 576              		.loc 1 324 0
 577 000e 0446     		mov	r4, r0
 326:Src/robotronik_protocol.c ****   FSM_CHECK_ERR(interface, RP_ERR_LINK | RP_ERR_UNEXPECTED_EOF);
 578              		.loc 1 326 0
 579 0010 3DB3     		cbz	r5, .L59
 327:Src/robotronik_protocol.c **** 
 328:Src/robotronik_protocol.c ****   /*
 329:Src/robotronik_protocol.c ****    * Checks the high byte of CRC, and triggers an error if it doesn't match.
 330:Src/robotronik_protocol.c ****    */
 331:Src/robotronik_protocol.c ****   if((interface->crc_accum >> 8) != FSM_DECODE_BYTE(interface, FSM_BYTE)){
 580              		.loc 1 331 0
 581 0012 90F80424 		ldrb	r2, [r0, #1028]	@ zero_extendqisi2
 582 0016 B0F81014 		ldrh	r1, [r0, #1040]
 583 001a 531E     		subs	r3, r2, #1
 584 001c 13F0FF03 		ands	r3, r3, #255
 585 0020 18BF     		it	ne
 586 0022 80F80434 		strbne	r3, [r0, #1028]
 587 0026 4FEA1122 		lsr	r2, r1, #8
 588 002a 14BF     		ite	ne
 589 002c 2B46     		movne	r3, r5
 590 002e 80F80454 		strbeq	r5, [r0, #1028]
 591 0032 9A42     		cmp	r2, r3
 592 0034 03D1     		bne	.L60
 332:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_CRC);
 333:Src/robotronik_protocol.c ****   }else{
 334:Src/robotronik_protocol.c ****     FSM_UPDATE(interface, RP_FSM_END);
 593              		.loc 1 334 0
 594 0036 134B     		ldr	r3, .L61
 595 0038 C0F80034 		str	r3, [r0, #1024]
 596 003c 38BD     		pop	{r3, r4, r5, pc}
 597              	.LVL39:
 598              	.L60:
 332:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_CRC);
 599              		.loc 1 332 0
 600 003e 40F20323 		movw	r3, #515
 601 0042 114A     		ldr	r2, .L61+4
 602 0044 1946     		mov	r1, r3
 603 0046 1380     		strh	r3, [r2]	@ movhi
 604 0048 FFF7FEFF 		bl	RP_Error_Handler
 605              	.LVL40:
 606 004c 0F4B     		ldr	r3, .L61+8
 607 004e C4F80034 		str	r3, [r4, #1024]
ARM GAS  /tmp/ccoJRFYJ.s 			page 18


 608 0052 0022     		movs	r2, #0
 609 0054 04F58573 		add	r3, r4, #266
 610 0058 A4F81024 		strh	r2, [r4, #1040]	@ movhi
 611 005c C4F80C34 		str	r3, [r4, #1036]
 612 0060 38BD     		pop	{r3, r4, r5, pc}
 613              	.LVL41:
 614              	.L59:
 615              	.LBB20:
 616              	.LBB21:
 326:Src/robotronik_protocol.c **** 
 617              		.loc 1 326 0
 618 0062 40F20123 		movw	r3, #513
 619 0066 084A     		ldr	r2, .L61+4
 620 0068 1946     		mov	r1, r3
 621 006a 1380     		strh	r3, [r2]	@ movhi
 622 006c FFF7FEFF 		bl	RP_Error_Handler
 623              	.LVL42:
 624 0070 064A     		ldr	r2, .L61+8
 625 0072 A4F81054 		strh	r5, [r4, #1040]	@ movhi
 626 0076 04F58573 		add	r3, r4, #266
 627 007a C4F80024 		str	r2, [r4, #1024]
 628 007e C4F80C34 		str	r3, [r4, #1036]
 629 0082 38BD     		pop	{r3, r4, r5, pc}
 630              	.LVL43:
 631              	.L62:
 632              		.align	2
 633              	.L61:
 634 0084 00000000 		.word	RP_FSM_END
 635 0088 00000000 		.word	.LANCHOR0
 636 008c 00000000 		.word	RP_FSM_INIT
 637              	.LBE21:
 638              	.LBE20:
 639              		.cfi_endproc
 640              	.LFE13:
 642              		.section	.text.RP_FSM_END,"ax",%progbits
 643              		.align	2
 644              		.thumb
 645              		.thumb_func
 647              	RP_FSM_END:
 648              	.LFB14:
 335:Src/robotronik_protocol.c ****   }
 336:Src/robotronik_protocol.c **** }
 337:Src/robotronik_protocol.c **** 
 338:Src/robotronik_protocol.c **** static void RP_FSM_END(RP_Interface *interface){
 649              		.loc 1 338 0
 650              		.cfi_startproc
 651              		@ args = 0, pretend = 0, frame = 0
 652              		@ frame_needed = 0, uses_anonymous_args = 0
 653              	.LVL44:
 654 0000 38B5     		push	{r3, r4, r5, lr}
 655              	.LCFI7:
 656              		.cfi_def_cfa_offset 16
 657              		.cfi_offset 3, -16
 658              		.cfi_offset 4, -12
 659              		.cfi_offset 5, -8
 660              		.cfi_offset 14, -4
 339:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
ARM GAS  /tmp/ccoJRFYJ.s 			page 19


 661              		.loc 1 339 0
 662 0002 D0F80834 		ldr	r3, [r0, #1032]
 663 0006 5A1C     		adds	r2, r3, #1
 664 0008 C0F80824 		str	r2, [r0, #1032]
 665              	.LVL45:
 340:Src/robotronik_protocol.c **** 
 341:Src/robotronik_protocol.c ****   /*
 342:Src/robotronik_protocol.c ****    * The last byte must be EOF. Otherwise, it is an error.
 343:Src/robotronik_protocol.c ****    */
 344:Src/robotronik_protocol.c ****   if(FSM_BYTE == 0x00){
 666              		.loc 1 344 0
 667 000c 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 338:Src/robotronik_protocol.c ****   FSM_GET_BYTE(interface);
 668              		.loc 1 338 0
 669 000e 0446     		mov	r4, r0
 670              		.loc 1 344 0
 671 0010 8DB1     		cbz	r5, .L67
 345:Src/robotronik_protocol.c ****     interface->received = true;
 346:Src/robotronik_protocol.c ****     RP_Packet_Received(interface, &interface->r_packet);
 347:Src/robotronik_protocol.c ****     FSM_RESET(interface);
 348:Src/robotronik_protocol.c ****   }else{
 349:Src/robotronik_protocol.c ****     FSM_ERR(interface, RP_ERR_LINK | RP_ERR_SIZE);
 672              		.loc 1 349 0
 673 0012 40F20223 		movw	r3, #514
 674              	.LVL46:
 675 0016 104A     		ldr	r2, .L68
 676              	.LVL47:
 677 0018 1946     		mov	r1, r3
 678 001a 1380     		strh	r3, [r2]	@ movhi
 679 001c FFF7FEFF 		bl	RP_Error_Handler
 680              	.LVL48:
 681 0020 0E4B     		ldr	r3, .L68+4
 682 0022 C4F80034 		str	r3, [r4, #1024]
 683 0026 0022     		movs	r2, #0
 684 0028 04F58573 		add	r3, r4, #266
 685 002c A4F81024 		strh	r2, [r4, #1040]	@ movhi
 686 0030 C4F80C34 		str	r3, [r4, #1036]
 687 0034 38BD     		pop	{r3, r4, r5, pc}
 688              	.LVL49:
 689              	.L67:
 690              	.LBB24:
 691              	.LBB25:
 345:Src/robotronik_protocol.c ****     interface->received = true;
 692              		.loc 1 345 0
 693 0036 0123     		movs	r3, #1
 694              	.LVL50:
 695 0038 80F81234 		strb	r3, [r0, #1042]
 696              	.LVL51:
 346:Src/robotronik_protocol.c ****     FSM_RESET(interface);
 697              		.loc 1 346 0
 698 003c 00F58471 		add	r1, r0, #264
 699 0040 FFF7FEFF 		bl	RP_Packet_Received
 700              	.LVL52:
 347:Src/robotronik_protocol.c ****   }else{
 701              		.loc 1 347 0
 702 0044 054A     		ldr	r2, .L68+4
 703 0046 A4F81054 		strh	r5, [r4, #1040]	@ movhi
ARM GAS  /tmp/ccoJRFYJ.s 			page 20


 704 004a 04F58573 		add	r3, r4, #266
 705 004e C4F80024 		str	r2, [r4, #1024]
 706 0052 C4F80C34 		str	r3, [r4, #1036]
 707 0056 38BD     		pop	{r3, r4, r5, pc}
 708              	.LVL53:
 709              	.L69:
 710              		.align	2
 711              	.L68:
 712 0058 00000000 		.word	.LANCHOR0
 713 005c 00000000 		.word	RP_FSM_INIT
 714              	.LBE25:
 715              	.LBE24:
 716              		.cfi_endproc
 717              	.LFE14:
 719              		.section	.text.RP_Build_Frame,"ax",%progbits
 720              		.align	2
 721              		.global	RP_Build_Frame
 722              		.thumb
 723              		.thumb_func
 725              	RP_Build_Frame:
 726              	.LFB3:
  87:Src/robotronik_protocol.c ****   if((packet->len <= 0) || (packet->len + 6 > RP_BUFFER_SIZE) || (packet->len > RP_MAX_PACKET_SIZE)
 727              		.loc 1 87 0
 728              		.cfi_startproc
 729              		@ args = 0, pretend = 0, frame = 0
 730              		@ frame_needed = 0, uses_anonymous_args = 0
 731              	.LVL54:
  88:Src/robotronik_protocol.c ****     err =  RP_ERR_INTERNAL | RP_ERR_ILLEGAL_ARGUMENTS;
 732              		.loc 1 88 0
 733 0000 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 734 0002 013B     		subs	r3, r3, #1
 735 0004 DBB2     		uxtb	r3, r3
 736 0006 F92B     		cmp	r3, #249
 737 0008 6AD8     		bhi	.L86
 738              	.LVL55:
  87:Src/robotronik_protocol.c ****   if((packet->len <= 0) || (packet->len + 6 > RP_BUFFER_SIZE) || (packet->len > RP_MAX_PACKET_SIZE)
 739              		.loc 1 87 0
 740 000a 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 741              	.LCFI8:
 742              		.cfi_def_cfa_offset 28
 743              		.cfi_offset 4, -28
 744              		.cfi_offset 5, -24
 745              		.cfi_offset 6, -20
 746              		.cfi_offset 7, -16
 747              		.cfi_offset 8, -12
 748              		.cfi_offset 9, -8
 749              		.cfi_offset 14, -4
  99:Src/robotronik_protocol.c ****   ENCODE_BYTE(id, p_buffer, p_code);
 750              		.loc 1 99 0
 751 000e DFF8E480 		ldr	r8, .L90+4
  98:Src/robotronik_protocol.c ****   UPDATE_CRC(crc_accum, id);
 752              		.loc 1 98 0
 753 0012 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 754              	.LVL56:
  99:Src/robotronik_protocol.c ****   ENCODE_BYTE(id, p_buffer, p_code);
 755              		.loc 1 99 0
 756 0014 38F81340 		ldrh	r4, [r8, r3, lsl #1]
ARM GAS  /tmp/ccoJRFYJ.s 			page 21


 757              	.LVL57:
 100:Src/robotronik_protocol.c ****     
 758              		.loc 1 100 0
 759 0018 B3B3     		cbz	r3, .L87
 100:Src/robotronik_protocol.c ****     
 760              		.loc 1 100 0 is_stmt 0 discriminator 2
 761 001a 4B70     		strb	r3, [r1, #1]
 762 001c 8E1C     		adds	r6, r1, #2
 763              	.LVL58:
 764 001e 8E46     		mov	lr, r1
 765              	.LVL59:
 766              	.L74:
 103:Src/robotronik_protocol.c ****   UPDATE_CRC(crc_accum, size);
 767              		.loc 1 103 0 is_stmt 1
 768 0020 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 769 0022 0433     		adds	r3, r3, #4
 770 0024 DBB2     		uxtb	r3, r3
 771              	.LVL60:
 104:Src/robotronik_protocol.c ****   *(p_buffer++) = size;
 772              		.loc 1 104 0
 773 0026 83EA1422 		eor	r2, r3, r4, lsr #8
 105:Src/robotronik_protocol.c ****   
 774              		.loc 1 105 0
 775 002a 06F10109 		add	r9, r6, #1
 104:Src/robotronik_protocol.c ****   *(p_buffer++) = size;
 776              		.loc 1 104 0
 777 002e 38F81220 		ldrh	r2, [r8, r2, lsl #1]
 105:Src/robotronik_protocol.c ****   
 778              		.loc 1 105 0
 779 0032 3370     		strb	r3, [r6]
 108:Src/robotronik_protocol.c ****     const uint8_t byte = packet->data[i];
 780              		.loc 1 108 0
 781 0034 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 782              	.LVL61:
 104:Src/robotronik_protocol.c ****   *(p_buffer++) = size;
 783              		.loc 1 104 0
 784 0036 82EA0422 		eor	r2, r2, r4, lsl #8
 785 003a 92B2     		uxth	r2, r2
 786              	.LVL62:
 787 003c 7546     		mov	r5, lr
 108:Src/robotronik_protocol.c ****     const uint8_t byte = packet->data[i];
 788              		.loc 1 108 0
 789 003e 53B3     		cbz	r3, .L76
 790 0040 0236     		adds	r6, r6, #2
 791              	.LVL63:
 792 0042 4B46     		mov	r3, r9
 793 0044 00F1010C 		add	ip, r0, #1
 794 0048 0027     		movs	r7, #0
 795 004a 0CE0     		b	.L79
 796              	.LVL64:
 797              	.L88:
 798              	.LBB26:
 111:Src/robotronik_protocol.c ****   }
 799              		.loc 1 111 0 discriminator 1
 800 004c 8EF80090 		strb	r9, [lr]
 801 0050 1D46     		mov	r5, r3
 802              	.LVL65:
ARM GAS  /tmp/ccoJRFYJ.s 			page 22


 803 0052 B146     		mov	r9, r6
 804              	.LVL66:
 805 0054 9E46     		mov	lr, r3
 806              	.L78:
 807              	.LBE26:
 108:Src/robotronik_protocol.c ****     const uint8_t byte = packet->data[i];
 808              		.loc 1 108 0 discriminator 2
 809 0056 4478     		ldrb	r4, [r0, #1]	@ zero_extendqisi2
 810 0058 0137     		adds	r7, r7, #1
 811              	.LVL67:
 812 005a BC42     		cmp	r4, r7
 813 005c 06F10106 		add	r6, r6, #1
 814              	.LVL68:
 815 0060 03F10103 		add	r3, r3, #1
 816 0064 17DD     		ble	.L76
 817              	.LVL69:
 818              	.L79:
 819              	.LBB27:
 109:Src/robotronik_protocol.c ****     UPDATE_CRC(crc_accum, byte);
 820              		.loc 1 109 0
 821 0066 1CF8015F 		ldrb	r5, [ip, #1]!	@ zero_extendqisi2
 822              	.LVL70:
 110:Src/robotronik_protocol.c ****     ENCODE_BYTE(byte, p_buffer, p_code);
 823              		.loc 1 110 0
 824 006a 85EA1224 		eor	r4, r5, r2, lsr #8
 111:Src/robotronik_protocol.c ****   }
 825              		.loc 1 111 0
 826 006e CEEB0309 		rsb	r9, lr, r3
 110:Src/robotronik_protocol.c ****     ENCODE_BYTE(byte, p_buffer, p_code);
 827              		.loc 1 110 0
 828 0072 38F81440 		ldrh	r4, [r8, r4, lsl #1]
 829 0076 84EA0222 		eor	r2, r4, r2, lsl #8
 830              	.LVL71:
 831 007a 92B2     		uxth	r2, r2
 832              	.LVL72:
 111:Src/robotronik_protocol.c ****   }
 833              		.loc 1 111 0
 834 007c 002D     		cmp	r5, #0
 835 007e E5D0     		beq	.L88
 111:Src/robotronik_protocol.c ****   }
 836              		.loc 1 111 0 is_stmt 0 discriminator 2
 837 0080 1D70     		strb	r5, [r3]
 838 0082 B146     		mov	r9, r6
 839              	.LVL73:
 840 0084 7546     		mov	r5, lr
 841              	.LVL74:
 842 0086 E6E7     		b	.L78
 843              	.LVL75:
 844              	.L87:
 845              	.LBE27:
 100:Src/robotronik_protocol.c ****     
 846              		.loc 1 100 0 is_stmt 1 discriminator 1
 847 0088 0E46     		mov	r6, r1
 848 008a 0123     		movs	r3, #1
 849              	.LVL76:
 850 008c 06F8023B 		strb	r3, [r6], #2
 851              	.LVL77:
ARM GAS  /tmp/ccoJRFYJ.s 			page 23


  94:Src/robotronik_protocol.c ****   uint16_t crc_accum = CRC_INIT;
 852              		.loc 1 94 0 discriminator 1
 853 0090 01EB030E 		add	lr, r1, r3
 854 0094 C4E7     		b	.L74
 855              	.LVL78:
 856              	.L76:
 116:Src/robotronik_protocol.c ****   ENCODE_BYTE(crc_low, p_buffer, p_code);
 857              		.loc 1 116 0
 858 0096 130A     		lsrs	r3, r2, #8
 859              	.LVL79:
 117:Src/robotronik_protocol.c ****   ENCODE_BYTE(crc_high, p_buffer, p_code);
 860              		.loc 1 117 0
 861 0098 12F0FF02 		ands	r2, r2, #255
 862              	.LVL80:
 863 009c 15D1     		bne	.L80
 117:Src/robotronik_protocol.c ****   ENCODE_BYTE(crc_high, p_buffer, p_code);
 864              		.loc 1 117 0 is_stmt 0 discriminator 1
 865 009e C5EB0905 		rsb	r5, r5, r9
 866              	.LVL81:
 867 00a2 8EF80050 		strb	r5, [lr]
 868 00a6 09F10102 		add	r2, r9, #1
 869              	.LVL82:
 870 00aa 4D46     		mov	r5, r9
 118:Src/robotronik_protocol.c ****   
 871              		.loc 1 118 0 is_stmt 1 discriminator 1
 872 00ac A3B9     		cbnz	r3, .L82
 873              	.LVL83:
 874              	.L89:
 875 00ae 551B     		subs	r5, r2, r5
 876              	.LVL84:
 877 00b0 89F80050 		strb	r5, [r9]
 878 00b4 501C     		adds	r0, r2, #1
 879              	.LVL85:
 880 00b6 1546     		mov	r5, r2
 881              	.L83:
 122:Src/robotronik_protocol.c **** 
 882              		.loc 1 122 0
 883 00b8 0346     		mov	r3, r0
 884              	.LVL86:
 885 00ba 0024     		movs	r4, #0
 121:Src/robotronik_protocol.c ****   *(p_buffer++) = RP_EOF;
 886              		.loc 1 121 0
 887 00bc 401B     		subs	r0, r0, r5
 888              	.LVL87:
 889 00be 1070     		strb	r0, [r2]
 890              	.LVL88:
 122:Src/robotronik_protocol.c **** 
 891              		.loc 1 122 0
 892 00c0 03F8014B 		strb	r4, [r3], #1
 893              	.LVL89:
 124:Src/robotronik_protocol.c **** }
 894              		.loc 1 124 0
 895 00c4 581A     		subs	r0, r3, r1
 125:Src/robotronik_protocol.c **** 
 896              		.loc 1 125 0
 897 00c6 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 898              	.LVL90:
ARM GAS  /tmp/ccoJRFYJ.s 			page 24


 899              	.L80:
 117:Src/robotronik_protocol.c ****   ENCODE_BYTE(crc_high, p_buffer, p_code);
 900              		.loc 1 117 0 discriminator 2
 901 00ca 89F80020 		strb	r2, [r9]
 902 00ce 09F10102 		add	r2, r9, #1
 903              	.LVL91:
 904 00d2 F146     		mov	r9, lr
 905              	.LVL92:
 118:Src/robotronik_protocol.c ****   
 906              		.loc 1 118 0 discriminator 2
 907 00d4 002B     		cmp	r3, #0
 908 00d6 EAD0     		beq	.L89
 909              	.LVL93:
 910              	.L82:
 911 00d8 1370     		strb	r3, [r2]
 912 00da 501C     		adds	r0, r2, #1
 913              	.LVL94:
 914 00dc 4A46     		mov	r2, r9
 915 00de EBE7     		b	.L83
 916              	.LVL95:
 917              	.L86:
 918              	.LCFI9:
 919              		.cfi_def_cfa_offset 0
 920              		.cfi_restore 4
 921              		.cfi_restore 5
 922              		.cfi_restore 6
 923              		.cfi_restore 7
 924              		.cfi_restore 8
 925              		.cfi_restore 9
 926              		.cfi_restore 14
  89:Src/robotronik_protocol.c ****     return -1;
 927              		.loc 1 89 0
 928 00e0 034B     		ldr	r3, .L90
 929 00e2 4FF48072 		mov	r2, #256
 930 00e6 1A80     		strh	r2, [r3]	@ movhi
  90:Src/robotronik_protocol.c ****   }
 931              		.loc 1 90 0
 932 00e8 4FF0FF30 		mov	r0, #-1
 933              	.LVL96:
 125:Src/robotronik_protocol.c **** 
 934              		.loc 1 125 0
 935 00ec 7047     		bx	lr
 936              	.L91:
 937 00ee 00BF     		.align	2
 938              	.L90:
 939 00f0 00000000 		.word	.LANCHOR0
 940 00f4 00000000 		.word	crc_table
 941              		.cfi_endproc
 942              	.LFE3:
 944              		.section	.text.RP_Sync,"ax",%progbits
 945              		.align	2
 946              		.global	RP_Sync
 947              		.thumb
 948              		.thumb_func
 950              	RP_Sync:
 951              	.LFB4:
 127:Src/robotronik_protocol.c ****   uint8_t byte = RP_EOF;
ARM GAS  /tmp/ccoJRFYJ.s 			page 25


 952              		.loc 1 127 0
 953              		.cfi_startproc
 954              		@ args = 0, pretend = 0, frame = 8
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956              	.LVL97:
 957 0000 10B5     		push	{r4, lr}
 958              	.LCFI10:
 959              		.cfi_def_cfa_offset 8
 960              		.cfi_offset 4, -8
 961              		.cfi_offset 14, -4
 962 0002 82B0     		sub	sp, sp, #8
 963              	.LCFI11:
 964              		.cfi_def_cfa_offset 16
 128:Src/robotronik_protocol.c **** 
 965              		.loc 1 128 0
 966 0004 02AB     		add	r3, sp, #8
 967 0006 0022     		movs	r2, #0
 968 0008 03F8012D 		strb	r2, [r3, #-1]!
 130:Src/robotronik_protocol.c ****     err = RP_ERR_LINK | RP_ERR_TIMEOUT;
 969              		.loc 1 130 0
 970 000c 0468     		ldr	r4, [r0]
 127:Src/robotronik_protocol.c ****   uint8_t byte = RP_EOF;
 971              		.loc 1 127 0
 972 000e 0A46     		mov	r2, r1
 130:Src/robotronik_protocol.c ****     err = RP_ERR_LINK | RP_ERR_TIMEOUT;
 973              		.loc 1 130 0
 974 0010 1846     		mov	r0, r3
 975              	.LVL98:
 976 0012 0121     		movs	r1, #1
 977              	.LVL99:
 978 0014 A047     		blx	r4
 979              	.LVL100:
 980 0016 08B9     		cbnz	r0, .L96
 981              	.L93:
 136:Src/robotronik_protocol.c **** 
 982              		.loc 1 136 0
 983 0018 02B0     		add	sp, sp, #8
 984              	.LCFI12:
 985              		.cfi_remember_state
 986              		.cfi_def_cfa_offset 8
 987              		@ sp needed
 988 001a 10BD     		pop	{r4, pc}
 989              	.L96:
 990              	.LCFI13:
 991              		.cfi_restore_state
 131:Src/robotronik_protocol.c ****     return -1;
 992              		.loc 1 131 0
 993 001c 034B     		ldr	r3, .L97
 994 001e 4FF40072 		mov	r2, #512
 995 0022 1A80     		strh	r2, [r3]	@ movhi
 132:Src/robotronik_protocol.c ****   }
 996              		.loc 1 132 0
 997 0024 4FF0FF30 		mov	r0, #-1
 998 0028 F6E7     		b	.L93
 999              	.L98:
 1000 002a 00BF     		.align	2
 1001              	.L97:
ARM GAS  /tmp/ccoJRFYJ.s 			page 26


 1002 002c 00000000 		.word	.LANCHOR0
 1003              		.cfi_endproc
 1004              	.LFE4:
 1006              		.section	.text.RP_Send,"ax",%progbits
 1007              		.align	2
 1008              		.global	RP_Send
 1009              		.thumb
 1010              		.thumb_func
 1012              	RP_Send:
 1013              	.LFB5:
 138:Src/robotronik_protocol.c ****   int len = RP_Build_Frame(packet, interface->buffer_out);
 1014              		.loc 1 138 0
 1015              		.cfi_startproc
 1016              		@ args = 0, pretend = 0, frame = 0
 1017              		@ frame_needed = 0, uses_anonymous_args = 0
 1018              	.LVL101:
 1019 0000 70B5     		push	{r4, r5, r6, lr}
 1020              	.LCFI14:
 1021              		.cfi_def_cfa_offset 16
 1022              		.cfi_offset 4, -16
 1023              		.cfi_offset 5, -12
 1024              		.cfi_offset 6, -8
 1025              		.cfi_offset 14, -4
 139:Src/robotronik_protocol.c **** 
 1026              		.loc 1 139 0
 1027 0002 00F54074 		add	r4, r0, #768
 138:Src/robotronik_protocol.c ****   int len = RP_Build_Frame(packet, interface->buffer_out);
 1028              		.loc 1 138 0
 1029 0006 0546     		mov	r5, r0
 139:Src/robotronik_protocol.c **** 
 1030              		.loc 1 139 0
 1031 0008 0846     		mov	r0, r1
 1032              	.LVL102:
 1033 000a 2146     		mov	r1, r4
 1034              	.LVL103:
 138:Src/robotronik_protocol.c ****   int len = RP_Build_Frame(packet, interface->buffer_out);
 1035              		.loc 1 138 0
 1036 000c 1646     		mov	r6, r2
 139:Src/robotronik_protocol.c **** 
 1037              		.loc 1 139 0
 1038 000e FFF7FEFF 		bl	RP_Build_Frame
 1039              	.LVL104:
 141:Src/robotronik_protocol.c ****     return -1;
 1040              		.loc 1 141 0
 1041 0012 431C     		adds	r3, r0, #1
 139:Src/robotronik_protocol.c **** 
 1042              		.loc 1 139 0
 1043 0014 0146     		mov	r1, r0
 1044              	.LVL105:
 141:Src/robotronik_protocol.c ****     return -1;
 1045              		.loc 1 141 0
 1046 0016 0DD0     		beq	.L101
 145:Src/robotronik_protocol.c ****     err = RP_ERR_LINK | RP_ERR_TIMEOUT;
 1047              		.loc 1 145 0
 1048 0018 2B68     		ldr	r3, [r5]
 1049 001a 2046     		mov	r0, r4
 1050              	.LVL106:
ARM GAS  /tmp/ccoJRFYJ.s 			page 27


 1051 001c 89B2     		uxth	r1, r1
 1052              	.LVL107:
 1053 001e 3246     		mov	r2, r6
 1054 0020 9847     		blx	r3
 1055              	.LVL108:
 1056 0022 00B9     		cbnz	r0, .L104
 1057              	.L100:
 151:Src/robotronik_protocol.c **** 
 1058              		.loc 1 151 0
 1059 0024 70BD     		pop	{r4, r5, r6, pc}
 1060              	.LVL109:
 1061              	.L104:
 146:Src/robotronik_protocol.c ****     return -1;
 1062              		.loc 1 146 0
 1063 0026 044B     		ldr	r3, .L105
 1064 0028 4FF40072 		mov	r2, #512
 1065 002c 1A80     		strh	r2, [r3]	@ movhi
 147:Src/robotronik_protocol.c ****   }
 1066              		.loc 1 147 0
 1067 002e 4FF0FF30 		mov	r0, #-1
 1068 0032 70BD     		pop	{r4, r5, r6, pc}
 1069              	.LVL110:
 1070              	.L101:
 1071 0034 F6E7     		b	.L100
 1072              	.L106:
 1073 0036 00BF     		.align	2
 1074              	.L105:
 1075 0038 00000000 		.word	.LANCHOR0
 1076              		.cfi_endproc
 1077              	.LFE5:
 1079              		.section	.text.RP_Process_Data,"ax",%progbits
 1080              		.align	2
 1081              		.global	RP_Process_Data
 1082              		.thumb
 1083              		.thumb_func
 1085              	RP_Process_Data:
 1086              	.LFB6:
 157:Src/robotronik_protocol.c ****   interface->p_in = data;
 1087              		.loc 1 157 0
 1088              		.cfi_startproc
 1089              		@ args = 0, pretend = 0, frame = 0
 1090              		@ frame_needed = 0, uses_anonymous_args = 0
 1091              	.LVL111:
 158:Src/robotronik_protocol.c **** 
 1092              		.loc 1 158 0
 1093 0000 C0F80814 		str	r1, [r0, #1032]
 1094              	.LVL112:
 160:Src/robotronik_protocol.c ****     interface->update_state(interface);
 1095              		.loc 1 160 0
 1096 0004 5AB1     		cbz	r2, .L113
 157:Src/robotronik_protocol.c ****   interface->p_in = data;
 1097              		.loc 1 157 0
 1098 0006 38B5     		push	{r3, r4, r5, lr}
 1099              	.LCFI15:
 1100              		.cfi_def_cfa_offset 16
 1101              		.cfi_offset 3, -16
 1102              		.cfi_offset 4, -12
ARM GAS  /tmp/ccoJRFYJ.s 			page 28


 1103              		.cfi_offset 5, -8
 1104              		.cfi_offset 14, -4
 1105 0008 0546     		mov	r5, r0
 160:Src/robotronik_protocol.c ****     interface->update_state(interface);
 1106              		.loc 1 160 0
 1107 000a 1446     		mov	r4, r2
 1108              	.LVL113:
 1109              	.L109:
 1110 000c 013C     		subs	r4, r4, #1
 1111              	.LVL114:
 161:Src/robotronik_protocol.c ****   }
 1112              		.loc 1 161 0
 1113 000e D5F80034 		ldr	r3, [r5, #1024]
 1114 0012 2846     		mov	r0, r5
 1115 0014 A4B2     		uxth	r4, r4
 1116 0016 9847     		blx	r3
 1117              	.LVL115:
 160:Src/robotronik_protocol.c ****     interface->update_state(interface);
 1118              		.loc 1 160 0
 1119 0018 002C     		cmp	r4, #0
 1120 001a F7D1     		bne	.L109
 1121 001c 38BD     		pop	{r3, r4, r5, pc}
 1122              	.LVL116:
 1123              	.L113:
 1124              	.LCFI16:
 1125              		.cfi_def_cfa_offset 0
 1126              		.cfi_restore 3
 1127              		.cfi_restore 4
 1128              		.cfi_restore 5
 1129              		.cfi_restore 14
 1130 001e 7047     		bx	lr
 1131              		.cfi_endproc
 1132              	.LFE6:
 1134              		.section	.text.RP_Wait_Packet,"ax",%progbits
 1135              		.align	2
 1136              		.global	RP_Wait_Packet
 1137              		.thumb
 1138              		.thumb_func
 1140              	RP_Wait_Packet:
 1141              	.LFB7:
 165:Src/robotronik_protocol.c ****   int start = interface->get_tick();
 1142              		.loc 1 165 0
 1143              		.cfi_startproc
 1144              		@ args = 0, pretend = 0, frame = 0
 1145              		@ frame_needed = 0, uses_anonymous_args = 0
 1146              	.LVL117:
 1147 0000 70B5     		push	{r4, r5, r6, lr}
 1148              	.LCFI17:
 1149              		.cfi_def_cfa_offset 16
 1150              		.cfi_offset 4, -16
 1151              		.cfi_offset 5, -12
 1152              		.cfi_offset 6, -8
 1153              		.cfi_offset 14, -4
 166:Src/robotronik_protocol.c ****   
 1154              		.loc 1 166 0
 1155 0002 4368     		ldr	r3, [r0, #4]
 165:Src/robotronik_protocol.c ****   int start = interface->get_tick();
ARM GAS  /tmp/ccoJRFYJ.s 			page 29


 1156              		.loc 1 165 0
 1157 0004 0446     		mov	r4, r0
 1158 0006 0E46     		mov	r6, r1
 166:Src/robotronik_protocol.c ****   
 1159              		.loc 1 166 0
 1160 0008 9847     		blx	r3
 1161              	.LVL118:
 1162 000a 0546     		mov	r5, r0
 1163              	.LVL119:
 169:Src/robotronik_protocol.c ****   
 1164              		.loc 1 169 0
 1165 000c 04E0     		b	.L118
 1166              	.LVL120:
 1167              	.L115:
 169:Src/robotronik_protocol.c ****   
 1168              		.loc 1 169 0 is_stmt 0 discriminator 1
 1169 000e 6368     		ldr	r3, [r4, #4]
 1170 0010 9847     		blx	r3
 1171              	.LVL121:
 1172 0012 401B     		subs	r0, r0, r5
 1173 0014 B042     		cmp	r0, r6
 1174 0016 03D2     		bcs	.L119
 1175              	.L118:
 169:Src/robotronik_protocol.c ****   
 1176              		.loc 1 169 0 discriminator 2
 1177 0018 94F81234 		ldrb	r3, [r4, #1042]	@ zero_extendqisi2
 1178 001c 002B     		cmp	r3, #0
 1179 001e F6D0     		beq	.L115
 1180              	.L119:
 171:Src/robotronik_protocol.c ****     return -1;
 1181              		.loc 1 171 0 is_stmt 1
 1182 0020 94F81234 		ldrb	r3, [r4, #1042]	@ zero_extendqisi2
 1183 0024 1BB1     		cbz	r3, .L122
 175:Src/robotronik_protocol.c ****   
 1184              		.loc 1 175 0
 1185 0026 0020     		movs	r0, #0
 1186 0028 84F81204 		strb	r0, [r4, #1042]
 178:Src/robotronik_protocol.c **** 
 1187              		.loc 1 178 0
 1188 002c 70BD     		pop	{r4, r5, r6, pc}
 1189              	.LVL122:
 1190              	.L122:
 172:Src/robotronik_protocol.c ****   }
 1191              		.loc 1 172 0
 1192 002e 4FF0FF30 		mov	r0, #-1
 1193 0032 70BD     		pop	{r4, r5, r6, pc}
 1194              		.cfi_endproc
 1195              	.LFE7:
 1197              		.section	.text.RP_Get_Error,"ax",%progbits
 1198              		.align	2
 1199              		.global	RP_Get_Error
 1200              		.thumb
 1201              		.thumb_func
 1203              	RP_Get_Error:
 1204              	.LFB15:
 350:Src/robotronik_protocol.c ****   }
 351:Src/robotronik_protocol.c **** }
ARM GAS  /tmp/ccoJRFYJ.s 			page 30


 352:Src/robotronik_protocol.c **** 
 353:Src/robotronik_protocol.c **** uint16_t RP_Get_Error(){
 1205              		.loc 1 353 0
 1206              		.cfi_startproc
 1207              		@ args = 0, pretend = 0, frame = 0
 1208              		@ frame_needed = 0, uses_anonymous_args = 0
 1209              		@ link register save eliminated.
 354:Src/robotronik_protocol.c ****   return err;
 1210              		.loc 1 354 0
 1211 0000 014B     		ldr	r3, .L124
 355:Src/robotronik_protocol.c **** }
 1212              		.loc 1 355 0
 1213 0002 1888     		ldrh	r0, [r3]
 1214 0004 7047     		bx	lr
 1215              	.L125:
 1216 0006 00BF     		.align	2
 1217              	.L124:
 1218 0008 00000000 		.word	.LANCHOR0
 1219              		.cfi_endproc
 1220              	.LFE15:
 1222              		.section	.bss.err,"aw",%nobits
 1223              		.align	1
 1224              		.set	.LANCHOR0,. + 0
 1227              	err:
 1228 0000 0000     		.space	2
 1229              		.text
 1230              	.Letext0:
 1231              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1232              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1233              		.file 4 "Inc/robotronik_protocol.h"
 1234              		.file 5 "Inc/crc_16.h"
ARM GAS  /tmp/ccoJRFYJ.s 			page 31


DEFINED SYMBOLS
                            *ABS*:0000000000000000 robotronik_protocol.c
     /tmp/ccoJRFYJ.s:21     .text.RP_FSM_INIT:0000000000000000 $t
     /tmp/ccoJRFYJ.s:25     .text.RP_FSM_INIT:0000000000000000 RP_FSM_INIT
     /tmp/ccoJRFYJ.s:61     .text.RP_FSM_INIT:0000000000000030 $d
     /tmp/ccoJRFYJ.s:163    .text.RP_FSM_ID:0000000000000000 RP_FSM_ID
     /tmp/ccoJRFYJ.s:67     .text.RP_Init_Interface:0000000000000000 $t
     /tmp/ccoJRFYJ.s:72     .text.RP_Init_Interface:0000000000000000 RP_Init_Interface
     /tmp/ccoJRFYJ.s:118    .text.RP_Init_Interface:000000000000002c $d
     /tmp/ccoJRFYJ.s:123    .text.RP_Packet_Received:0000000000000000 $t
     /tmp/ccoJRFYJ.s:128    .text.RP_Packet_Received:0000000000000000 RP_Packet_Received
     /tmp/ccoJRFYJ.s:141    .text.RP_Error_Handler:0000000000000000 $t
     /tmp/ccoJRFYJ.s:146    .text.RP_Error_Handler:0000000000000000 RP_Error_Handler
     /tmp/ccoJRFYJ.s:159    .text.RP_FSM_ID:0000000000000000 $t
     /tmp/ccoJRFYJ.s:239    .text.RP_FSM_ID:0000000000000070 $d
     /tmp/ccoJRFYJ.s:253    .text.RP_FSM_SIZE:0000000000000000 RP_FSM_SIZE
     /tmp/ccoJRFYJ.s:249    .text.RP_FSM_SIZE:0000000000000000 $t
     /tmp/ccoJRFYJ.s:350    .text.RP_FSM_SIZE:0000000000000094 $d
     /tmp/ccoJRFYJ.s:364    .text.RP_FSM_DATA:0000000000000000 RP_FSM_DATA
     /tmp/ccoJRFYJ.s:360    .text.RP_FSM_DATA:0000000000000000 $t
     /tmp/ccoJRFYJ.s:453    .text.RP_FSM_DATA:0000000000000088 $d
     /tmp/ccoJRFYJ.s:467    .text.RP_FSM_CRC_LOW:0000000000000000 RP_FSM_CRC_LOW
     /tmp/ccoJRFYJ.s:463    .text.RP_FSM_CRC_LOW:0000000000000000 $t
     /tmp/ccoJRFYJ.s:543    .text.RP_FSM_CRC_LOW:0000000000000080 $d
     /tmp/ccoJRFYJ.s:556    .text.RP_FSM_CRC_HIGH:0000000000000000 RP_FSM_CRC_HIGH
     /tmp/ccoJRFYJ.s:552    .text.RP_FSM_CRC_HIGH:0000000000000000 $t
     /tmp/ccoJRFYJ.s:634    .text.RP_FSM_CRC_HIGH:0000000000000084 $d
     /tmp/ccoJRFYJ.s:647    .text.RP_FSM_END:0000000000000000 RP_FSM_END
     /tmp/ccoJRFYJ.s:643    .text.RP_FSM_END:0000000000000000 $t
     /tmp/ccoJRFYJ.s:712    .text.RP_FSM_END:0000000000000058 $d
     /tmp/ccoJRFYJ.s:720    .text.RP_Build_Frame:0000000000000000 $t
     /tmp/ccoJRFYJ.s:725    .text.RP_Build_Frame:0000000000000000 RP_Build_Frame
     /tmp/ccoJRFYJ.s:939    .text.RP_Build_Frame:00000000000000f0 $d
     /tmp/ccoJRFYJ.s:945    .text.RP_Sync:0000000000000000 $t
     /tmp/ccoJRFYJ.s:950    .text.RP_Sync:0000000000000000 RP_Sync
     /tmp/ccoJRFYJ.s:1002   .text.RP_Sync:000000000000002c $d
     /tmp/ccoJRFYJ.s:1007   .text.RP_Send:0000000000000000 $t
     /tmp/ccoJRFYJ.s:1012   .text.RP_Send:0000000000000000 RP_Send
     /tmp/ccoJRFYJ.s:1075   .text.RP_Send:0000000000000038 $d
     /tmp/ccoJRFYJ.s:1080   .text.RP_Process_Data:0000000000000000 $t
     /tmp/ccoJRFYJ.s:1085   .text.RP_Process_Data:0000000000000000 RP_Process_Data
     /tmp/ccoJRFYJ.s:1135   .text.RP_Wait_Packet:0000000000000000 $t
     /tmp/ccoJRFYJ.s:1140   .text.RP_Wait_Packet:0000000000000000 RP_Wait_Packet
     /tmp/ccoJRFYJ.s:1198   .text.RP_Get_Error:0000000000000000 $t
     /tmp/ccoJRFYJ.s:1203   .text.RP_Get_Error:0000000000000000 RP_Get_Error
     /tmp/ccoJRFYJ.s:1218   .text.RP_Get_Error:0000000000000008 $d
     /tmp/ccoJRFYJ.s:1223   .bss.err:0000000000000000 $d
     /tmp/ccoJRFYJ.s:1227   .bss.err:0000000000000000 err
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
crc_table
